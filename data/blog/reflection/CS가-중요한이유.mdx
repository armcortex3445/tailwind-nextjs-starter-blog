---
title: '[성찰] CS가 중요한 이유'
date: '2025-02-20'
tags: ['쉬운코드']
draft: false
---

# 배경

- CS에 어떻게 개발에 도움이 되는지를 이해하는 시간이 되었으면 합니다.
- 무작정 CS 지식을 학습 하기 보다는, CS 지식이 현업에 어떻게 연결되어있는지 알아보는 시간이 되었으면 합니다.
- 앞으로 배울 CS 지식을 어덯게 현업에 사용해 볼지 스스로 돌아볼 시간이 되었으면 합니다.

# 결론

- 다음 4가지 지표는 CS 지식에 비례하는 경향이 있습니다.

1. 어플리케이션의 성능
2. SW 운영 및 유지보수의 안전성
3. 개발 지식 학습 속도
4. 개발, 학습 등 설계시 전체적인 큰그림 실체성

# 예제

## Web Server App에 In-Memory Cache를 구현할 때,

### 필요한 개념

1. Server App이 실행되는 시스템의 자원과 한계
2. 힙,스택, 등의 메모리 구조와 App 객체의 관계
3. GC 동작과 App 성능의 관계

### 고려해야하는 측면

1. In-memory Cache 크기의 최대값은 시스템이 제공할 수 있는 메모리 크기이다.
   - 시스템 실행시 기본적으로 필요한 메모리
   - App 실행시 기본적으로 필요한 메모리
   - App 실행시 동적 할당되는 메모리
   - 즉, 남은 메모리 만큼만 Cache로 사용할 수 있다.
2. App에서 생성된 객체는 스택 또는 힙에 저장되므로, App 실행시 메모리 공간은 동적으로 변화한다.
   - App 실행시, 예상보다 많은 메모리가 필요할 수 있다.
   - 메모리 공간에 여유가 부족하여 GC가 빈번하게 실행될 수 있다.
3. 빈번한 GC는 App 성능을 저하시킨다.
   - GC는 메모리 확보를 위해서 실행된다. 이때, App은 실행을 지연시키고 CPU 점유율을 증가시킨다.
   - Cache로 동적할당된 메모리는 GC가 해제할 수 없으므로, 빈번한 GC 동작은 Cache 크기에 영향을 받는다.

### 대안

- 캐시 메모리 크기 제한
- WebServer와 DB 사이에 Cache Server 생성
  - cache Server는 Caching 작업에 집중하고, web Server는 본연 동작에 신경쓰면 된다.

## Java Spring 환경에서 객체 필드 쓰기 작업 시,

## 예제

- Http Api의 요청 횟수를 측정하는 로직

```Java
@RestController
public class HelloCounter {
    private int count= 0;

    @GetMapping("/")
    public String greeting(){
        count++;
        return "hello world~!";
    }
}
```

### 필요한 개념

1. Java Spring의 Multi-threading 기반 동작
2. race condition
3. 프로그래밍 언어와 기계어의 관계
4. scheduling

### 고려해야하는 측면

1. 멀티 스레딩의 공유자원 쓰기 작업 결과를 예측할 수 없다.
   - 복수의 클라이언트 요청을 처리하기 위해 JAVA Spring은 멀티 스레딩 기반으로 동작한다.
   - 동일한 프로세스내에 생성된 스레드들은 힙 메모리 공간을 공유한다.
   - HelloCounter 객체는 싱글톤 패턴이므로, 모든 스레드는 동일한 객체를 참조하고, 동일한 count 필드에 접근한다.
   - 멀티 스레드는 race condition 발생시킬 여지가 있다.
2. 동일한 자원을 두고 쓰기 작업을 진행하므로, 작업 결과를 예측할 수 없다.
   - 동일한 자원을 두고 스레드들이 경쟁을 하게 된다.(race condition)
   - 동일한 메모리에 있는 값을 동시에 쓰기 작업을 진행하게 되면, 예상치 못한 결과가 발생한다.
   - 동일한 메모리에 있는 값을 스레드들이 스케줄링되어 순차적으로 읽어도, 예상치 못한 결과가 발생한다.
3. 복수의 스레드가 동시에 동일한 메모리(count)에 읽기 쓰기 작업을 진행 하므로, 런타임 에러가 발생하거나 작업결과를 예상할 수 없다.
   - count++; 코드는 즉시 count 값을 증가시키지 않는다.
   - count++; 코드는 기계어로 컴파일되어 컴퓨터가 실행시킨다.
   - count++; 코드에는 메모리 읽기->읽은 값 1 증가 -> 메모리에 값 저장의 단계로 이뤄진다.
   - 복수의 스레드가 코드를 실행하면, 읽기 작업 중인 메모리에 쓰기가 발생할 수 있고, 쓰기 작업중인 메모리에 읽기 작업이 발생할 수 있다.
   - CPU 입장에서는 기계어 실행시 오류를 감지하여 에러를 발생시킬 수 있다.
   - CPU 입장에서는 기계어 실행시 문제가 없으면, 실행만 할 뿐이다.
4. 복수의 스레드가 동일한 CPU에서 스케줄링 되더라도, 작업 결과를 예측할 수 없다.
   - count++; 코드는 메모리 읽기->읽은 값 1 증가 -> 메모리에 값 저장의 단계로 이뤄진다.
   - 스레드에서 메모리 읽기 도중 스케줄링에의해 다른 스레드로 컨텍스트 스위칭이 발생한다면, 다른 스레드 입장에서는 count 값이 변화하지 않은 것으로 관측된다.
   - CPU의 스레드 스케줄링을 기대한 순서로 스레드를 동작시킬 보장이 없으므로, 작업결과를 예측할 수 없다.

### 대안

- count 변수 synchronization
  - 멀티 스레드가아닌 단일 스레드로 count++ 실행하도록 한다.
  - 멀티 스레드 장점이 사라지는 대안
- thread-safe 클래스 사용
  - 공유 자원의 원자성을 보장.

```Java
@RestController
public class HelloCounter {
    private AtomicInteger count=  new AtomicInteger();

    @GetMapping("/")
    public String greeting(){
        count.incrementAndGet();
        return "hello world~!";
    }
}
```

## DB에서 쿼리문 조건 설정시

- 다음 쿼리 패턴들을 사용한다고 가정

```
... WHERE create_at="2001-01-01" AND user_id = 7915

... WHERE create_at > "2001-01-01" AND user_id = 7915
```

### 필요한 개념

1. composite index

### 고려해야하는 측면

1. 복수의 열로 쿼리 조건 설정시, 탐색 성능은 Composite Index에 영향을 받는다.
   - composite Index는 복수의 열로 구성된 Index이므로, 각각의 컬럼의 Index를 활용하여 탐색하는 것보다 composite Index가 더 빠르다.
   - composite Index 생성시 입력된 컬럼 순서를 기준으로 탐색을 시작하므로, 'WHERE create_at > "2001-01-01" AND user_id = 7915' 패턴 성능 향상을 위해선, (user_id,create_at) 순서로 입력하여 composite Index를 생성해야한다.

## 암호화가 필요한 경우

- 사용자의 비밀번호를 암호화하여 DB에 저장하려고 한다.

### 필요한 개념

1. 암호화와 복호화

### 고려해야하는 측면

1. 외부 또는 내부 관계자가 복호화할 가능성을 주어선 안된다.
   - 대칭 암호화를 사용한다면, 대칭키가 노출될었을 때, 복호화가 가능해진다.
   - 대칭키의 관리가 보안성에 연관을 준다.

### 대안

- 비대칭 암호화 사용
  - 공개 키와 개인 키 두가지를 사용하여 암호화한다.
  - 두 개의 키에 접근하는 것은 보안 메커니즘과 수한적 난제 덕분에 불가능에 가깝다.
- 단방향 해시함수 사용
  - 암호화는 가능하지만, 복호화는 불가능한 단방향 로직을 제공한다.

## 그외 짧은 사례

### 공통적인 결과

- 기술 문서 독해나 기술 관련 설명을 막힘없이 이해할 수 있다.
- 현재 직면한 문제를 다양한 관점에서 분석하여 해결할 수 있게 된다.

### 자료구조

- Array와 HashMap을 적절하게 사용할 수 있다 => 성능 향상
- 상황에 알맞은 자료구조를 사용할 수 있다 => 적재 적소에 기술 사용
  - race condition 예방으로 ConcurrentHashMap 사용
  - 데이터 암호화를 위해 Hash 사용
- DB에서 사용하는 자료구조의 동작을 설명할수 있다 => 학습 속도 향상, 적재 적소에 기술 사용

### OS

- race condition 가능성을 고려하여, thread-safe 적용할 수 있다 => 데이터 정합성 향상
- Local Cache 같이 공유 객체를 immutable 타입으로 생성할 것을 고려한다 => 데이터 정합성 향상
- coroutine, WebFlux 개념과 원리를 금방 설명할수 있다 => 학습 속도 향상, 적재적소 기술 사용

### DB

- DB의 데이터 관리 방식을 설명할수 있다 => 학습 속도 향상, 적재 적소에 기술 사용
- 테이블 설계시, non-incremental 값을 primary key로 사용하는 것을 망설인다 => 성능 하락 방지
- 테이블 설계 시, 특정 컬럼의 크기가 매우 큰 경우에는 해당 컬럼만 분리하여 별도의 테이블로 구성할 것을 고려한다. => 테이블 조회 성능 향상
- DB 테이블 설계를 잘못 해서 중복 데이터가 생기는 것을 방지한다 => 데이터 정합성 향상
- 서비스 특성에 맞춰 DB 퍼포먼스를 향상시킬 방법(sharding, partitioning, replica)을 알고 있다. => 성능 및 안정성 향상
- DB에서 update 내용이 사라졌을 때, isolation level을 의심할 수 있다 => 데이터 정합성 향상

### Network

- TCP 특성을 잘 알고, HTTP/3 탄생과 특징을 설명할수 있다. => 학습 속도 향상, 성능 향상
- HTTP/3을 왜 앱과 웹이 통신할 때 사용하는지 사용자 경험측면에서 설명할 수 있다 => 학습 속도 향상, 성능 향상
- connection pool이 왜 필요한지 이해하고 있어서 적절하게 튜닝할 수 있다. => 성능 향상
- application level에서 새로운 프로토콜 정의가 필요한 경우, 서비스 특성에 따른 적절한 transport layer 프로토콜을 선택할 수 있다 => 성능 혹은 안정성 향상
- 통신 도중 hang이 발생 했을 때, 빠르게 추적 및 해결할 수 있다 => 운영 측면에서 도움
- 웹 브라우저에서 URL 주소창에 주소를 입력했을 때, 웹 브라우저에 페이지가 렌더링되는 과정 설명 할 수 있다 => 큰 그림을 그릴 수 있다.

## 참조

- 회원만 시청가능.
  https://www.youtube.com/watch?v=9e-0tZtT8ZA&t=26s
